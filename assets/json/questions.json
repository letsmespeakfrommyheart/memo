[
  {
    "question": "Что такое объектно-ориентированное программирование (ООП)?",
    "answer": "ООП (Объектно-ориентированное программирование) — это подход к разработке программ, при котором код организуется в виде объектов. В ООП данные и действия с ними (методы) объединяются в единую структуру — объект, что помогает лучше структурировать код и управлять сложными проектами. Каждый объект представляет собой экземпляр класса, а классы могут наследовать свойства и методы друг от друга, образуя иерархию. Такой подход позволяет легко повторно использовать код, делая его более расширяемым и поддерживаемым."
  },
  {
    "question": "Какие принципы лежат в основе ООП?",
    "answer": "Принципы ООП:  \n- Абстракция  \n- Инкапсуляция  \n- Наследование  \n- Полиморфизм"
  },
  {
    "question": "Что такое абстракция в ООП?",
    "answer": "Dart поддерживает абстракцию с помощью классов и интерфейсов, что позволяет создавать структуры для моделирования объектов реального мира. С помощью абстрактных классов (abstract) можно определять базовые методы и свойства, которые будут обязательны для реализации в наследниках, оставляя детали скрытыми."
  },
  {
    "question": "Что такое инкапсуляция в ООП?",
    "answer": "Инкапсуляция в Dart достигается за счет контроля видимости переменных и методов. Скрытые члены класса (переменные и методы) обозначаются префиксом _, что делает их доступными только внутри файла, где определён класс. Это позволяет защищать данные класса от прямого изменения извне и управлять доступом через методы."
  },
  {
    "question": "Что такое наследование в ООП?",
    "answer": "Dart поддерживает наследование, что позволяет одному классу наследовать поля и методы другого с помощью ключевого слова extends. Классы-потомки могут расширять или изменять поведение методов родительского класса, а также добавлять собственные свойства и методы. Множественное наследование Dart не поддерживает, но можно реализовать интерфейсы с помощью ключевого слова implements."
  },
  {
    "question": "Что такое полиморфизм в ООП?",
    "answer": "В Dart полиморфизм позволяет использовать объекты разных классов через общие интерфейсы или базовые классы. Методы базового класса можно переопределять в дочерних классах, что даёт возможность создать различные реализации для одного и того же метода. Полиморфизм позволяет, например, работать с несколькими типами объектов через один и тот же метод или интерфейс, не зная их точного типа."
  },
  {
    "question": "Что такое SOLID?",
    "answer": "SOLID — это набор из пяти принципов объектно-ориентированного программирования, которые помогают создавать код, который легче тестировать, модифицировать и расширять, минимизируя вероятность появления багов и упрощая добавление нового функционала. Эти принципы помогают улучшить проектирование и структуру кода, делая систему более устойчивой и удобной для работы в долгосрочной перспективе."
  },
  {
    "question": "Что означает принцип единственной ответственности (Single Responsibility Principle)?",
    "answer": "Каждый класс должен иметь только одну причину для изменения, то есть он должен выполнять только одну задачу. Если класс отвечает за несколько обязанностей, это делает его сложным для тестирования, поддержания и модификации.  \nПример: Класс, который занимается обработкой данных и их выводом на экран, нарушает этот принцип. Лучше создать два класса: один для обработки данных, другой — для вывода."
  },
  {
    "question": "Что означает принцип открытости/закрытости (Open/Closed Principle)?",
    "answer": "Классы должны быть открыты для расширения, но закрыты для изменения. Это означает, что поведение класса можно расширять, не изменяя его исходный код.  \nПример: Вместо того, чтобы изменять существующие методы класса, можно создать подклассы, которые расширяют функциональность."
  },
  {
    "question": "Что означает принцип подстановки Лисков (Liskov Substitution Principle)?",
    "answer": "Объекты подклассов должны быть взаимозаменяемы с объектами базового класса без нарушения работы программы. Если подкласс изменяет поведение базового класса так, что это вызывает проблемы, то это нарушает принцип Лисков.  \nПример: Если у нас есть класс \"Животное\", а от него наследуется класс \"Собака\", то объект \"Собака\" должен вести себя так же, как и объект \"Животное\", когда используется в коде."
  },
  {
    "question": "Что означает принцип разделения интерфейса (Interface Segregation Principle)?",
    "answer": "Классы, реализующие интерфейс, не должны зависеть от интерфейсов, которые они не используют. Это означает, что большие интерфейсы нужно разделять на более мелкие, чтобы классы могли работать только с теми методами, которые им действительно нужны.  \nПример: Если интерфейс содержит методы для работы с документами и изображениями, а класс работает только с документами, то следует разделить этот интерфейс на два, чтобы класс не зависел от методов, с которыми он не работает."
  },
  {
    "question": "Что означает принцип инверсии зависимостей (Dependency Inversion Principle)?",
    "answer": "Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций. Также, абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.  \nПример: Вместо того, чтобы класс зависел от конкретного типа объекта (например, от класса \"DatabaseConnection\"), он должен зависеть от абстракции (например, интерфейса \"DatabaseConnectionInterface\"), что позволяет легче менять реализацию без изменения основного класса."
  },
  {
    "question": "Что такое BLoC?",
    "answer": "BLoC — это архитектурный паттерн, который отделяет бизнес-логику от пользовательского интерфейса. Он помогает создавать приложения с четкой структурой, что особенно полезно для тестируемости и масштабируемости.\nОсновная идея: пользовательский интерфейс (UI) взаимодействует с бизнес-логикой через потоки данных (Streams), обеспечивая реактивный подход."
  },
  {
    "question": "Какие основные компоненты есть в BLoC?",
    "answer": "Основные компоненты BLoC:\n● Events (События):\n  ● Пользовательские действия или внешние триггеры (например, нажатие кнопки).\n  ● Передаются в BLoC для обработки.\n● State (Состояние):\n  ● BLoC возвращает новое состояние на основе обработанного события.\n  ● Это состояние передается в UI, который обновляется автоматически.\n● Streams:\n  ● Используются для передачи данных между BLoC и UI.\n  ● Входящий поток: события.\n  ● Исходящий поток: состояние."
  },
  {
    "question": "Как работает BLoC?",
    "answer": "1. Пользователь взаимодействует с UI (например, нажимает кнопку).\n2. UI отправляет событие в BLoC.\n3. BLoC обрабатывает событие, выполняя бизнес-логику (например, обращение к API или работе с базой данных).\n4. На основе результата BLoC эмитирует новое состояние.\n5. UI подписывается на поток состояний и обновляется автоматически."
  },
  {
    "question": "Какие преимущества у BLoC?",
    "answer": "Преимущества BLoC:\n1. Разделение ответственности:\n   ● UI и бизнес-логика отделены, что улучшает читаемость кода.\n2. Масштабируемость:\n   ● Легко добавлять новые функции, не затрагивая другие модули.\n3. Тестируемость:\n   ● Бизнес-логику можно тестировать отдельно от UI.\n4. Универсальность:\n   ● Работает на всех платформах Flutter (мобильных, веб, десктопных)."
  },
  {
    "question": "Когда стоит использовать BLoC?",
    "answer": "Когда использовать BLoC:\n● Если проект:\n  ● Сложный и требует четкого разделения слоёв.\n  ● Нужно управлять состоянием, зависящим от событий (например, фильтрация, поиск, авторизация).\n  ● Требует высокой тестируемости.\n● В небольших приложениях можно обойтись более простыми подходами, такими как Provider или Riverpod."
  },
  {
    "question": "Что такое ChangeNotifier?",
    "answer": "ChangeNotifier — это класс, который используется для управления состоянием в приложении. Он уведомляет подписчиков (например, виджеты), когда происходит изменение данных. Это удобно для реализации паттерна наблюдатель. \nЧтобы подписаться на изменения, нужно использовать метод addListener. Для уведомления нужно вызвать notifyListeners."
  },
  {
    "question": "Что такое ValueNotifier?",
    "answer": "ValueNotifier — это упрощённая версия ChangeNotifier, которая работает с одним значением. Он уведомляет слушателей, когда это значение изменяется. Это полезно для простых сценариев, где нужно отслеживать одно состояние, например, текущий индекс или выбранный элемент."
  },
  {
    "question": "Как ChangeNotifier связан с другими паттернами?",
    "answer": "ChangeNotifier часто используется с Provider, чтобы интегрировать управление состоянием в дерево виджетов."
  },
  {
    "question": "Как ValueNotifier связан с другими паттернами?",
    "answer": "ValueNotifier не требует Provider, но может использоваться с ValueListenableBuilder, который упрощает работу с UI."
  },
  {
    "question": "Чем отличаются ChangeNotifier и ValueNotifier?",
    "answer": "ValueNotifier работает с одним значением и имеет встроенное поле value, которое легко изменяется и отслеживается. \nChangeNotifier более гибкий и используется для управления сложными состояниями. Можно создавать произвольные свойства и методы, а затем уведомлять слушателей о любых изменениях."
  },
  {
    "question": "Какие подходы для управления навигацией предлагает Flutter?",
    "answer": "Flutter предлагает два подхода для управления навигацией в приложении:\n● Navigation 1.0 (Imperative API) – традиционная императивная навигация.\n● Navigation 2.0 (Declarative API) – более современный и гибкий подход."
  },
  {
    "question": "Как работает Navigation 1.0 (Императивный подход)?",
    "answer": "● Как работает:\n  - Используется класс Navigator, который управляет стеком маршрутов (Route).\n  - Навигация осуществляется с помощью методов:\n    ● Navigator.push() — добавление нового маршрута в стек.\n    ● Navigator.pop() — удаление текущего маршрута.\n  - Каждый маршрут добавляется или удаляется из стека явно, по команде.\n● Простота и ограничение:\n  - Этот подход подходит для линейных сценариев навигации или небольших приложений.\n  - Проблемы возникают при работе со сложными сценариями:\n    ● Глубокая вложенность маршрутов.\n    ● Поддержка глубоких ссылок (deep linking).\n    ● Сложность синхронизации состояния с URL (особенно в веб-приложениях)."
  },
  {
    "question": "Как работает Navigation 2.0 (Декларативный подход)?",
    "answer": "● Как работает:\n  - Навигация определяется состоянием приложения.\n  - Включает следующие ключевые компоненты:\n    ● Router и RouteInformationParser — обрабатывают входящие данные маршрута (например, URL).\n    ● RouterDelegate — управляет текущим состоянием и интерфейсом навигации.\n    ● Navigator внутри Router используется для работы со стеком экранов.\n● Преимущества:\n  - Полный контроль над состоянием приложения.\n  - Легкость работы с глубокими ссылками и платформенными маршрутами (например, веб-URL).\n  - Удобство для реализации сложных сценариев навигации.\n● Недостатки:\n  - Реализация сложнее по сравнению с Navigation 1.0."
  },
  {
    "question": "Какие основные отличия между декларативной и императивной навигацией?",
    "answer": "● Императивная навигация (Navigation 1.0):\n  - Разработчик явно управляет переходами с помощью вызовов функций (Navigator.push()).\n  - Это удобно для простых сценариев, но плохо масштабируется в сложных приложениях.\n● Декларативная навигация (Navigation 2.0):\n  - Навигация определяется состоянием приложения, а не прямыми вызовами.\n  - Вы описываете, какие маршруты доступны, а система автоматически синхронизирует интерфейс с состоянием."
  },
  {
    "question": "Как реализована декларативная навигация в go_router?",
    "answer": "● Особенности:\n  - Навигация описывается в виде конфигурации:\n    ● Указывается начальный маршрут, дочерние маршруты и параметры.\n  - Используются методы, такие как context.go() и context.push(), чтобы изменить состояние навигации.\n● Проявление декларативности:\n  - Маршруты определены как часть состояния приложения.\n  - Изменение маршрута изменяет состояние, а не управляет навигацией напрямую."
  },
  {
    "question": "Как реализована декларативная навигация в auto_route?",
    "answer": "● Особенности:\n  - Используются аннотации для описания маршрутов, и маршруты генерируются автоматически.\n  - Переходы между страницами осуществляются с помощью объектов, например, PetDetailsRoute.\n● Проявление декларативности:\n  - Навигация строится через аннотации и состояние приложения.\n  - Генерация кода упрощает управление маршрутами, исключая необходимость ручного управления состоянием."
  }
]

