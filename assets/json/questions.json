[
  {
    "question": "Что такое объектно-ориентированное программирование (ООП)?",
    "answer": "ООП (Объектно-ориентированное программирование) — это подход к разработке программ, при котором код организуется в виде объектов. В ООП данные и действия с ними (методы) объединяются в единую структуру — объект, что помогает лучше структурировать код и управлять сложными проектами. Каждый объект представляет собой экземпляр класса, а классы могут наследовать свойства и методы друг от друга, образуя иерархию. Такой подход позволяет легко повторно использовать код, делая его более расширяемым и поддерживаемым."
  },
  {
    "question": "Какие принципы лежат в основе ООП?",
    "answer": "Принципы ООП:  \n- Абстракция  \n- Инкапсуляция  \n- Наследование  \n- Полиморфизм"
  },
  {
    "question": "Что такое абстракция в ООП?",
    "answer": "Dart поддерживает абстракцию с помощью классов и интерфейсов, что позволяет создавать структуры для моделирования объектов реального мира. С помощью абстрактных классов (abstract) можно определять базовые методы и свойства, которые будут обязательны для реализации в наследниках, оставляя детали скрытыми."
  },
  {
    "question": "Что такое инкапсуляция в ООП?",
    "answer": "Инкапсуляция в Dart достигается за счет контроля видимости переменных и методов. Скрытые члены класса (переменные и методы) обозначаются префиксом _, что делает их доступными только внутри файла, где определён класс. Это позволяет защищать данные класса от прямого изменения извне и управлять доступом через методы."
  },
  {
    "question": "Что такое наследование в ООП?",
    "answer": "Dart поддерживает наследование, что позволяет одному классу наследовать поля и методы другого с помощью ключевого слова extends. Классы-потомки могут расширять или изменять поведение методов родительского класса, а также добавлять собственные свойства и методы. Множественное наследование Dart не поддерживает, но можно реализовать интерфейсы с помощью ключевого слова implements."
  },
  {
    "question": "Что такое полиморфизм в ООП?",
    "answer": "В Dart полиморфизм позволяет использовать объекты разных классов через общие интерфейсы или базовые классы. Методы базового класса можно переопределять в дочерних классах, что даёт возможность создать различные реализации для одного и того же метода. Полиморфизм позволяет, например, работать с несколькими типами объектов через один и тот же метод или интерфейс, не зная их точного типа."
  },
  {
    "question": "Что такое SOLID?",
    "answer": "SOLID — это набор из пяти принципов объектно-ориентированного программирования, которые помогают создавать код, который легче тестировать, модифицировать и расширять, минимизируя вероятность появления багов и упрощая добавление нового функционала. Эти принципы помогают улучшить проектирование и структуру кода, делая систему более устойчивой и удобной для работы в долгосрочной перспективе."
  },
  {
    "question": "Что означает принцип единственной ответственности (Single Responsibility Principle)?",
    "answer": "Каждый класс должен иметь только одну причину для изменения, то есть он должен выполнять только одну задачу. Если класс отвечает за несколько обязанностей, это делает его сложным для тестирования, поддержания и модификации.  \nПример: Класс, который занимается обработкой данных и их выводом на экран, нарушает этот принцип. Лучше создать два класса: один для обработки данных, другой — для вывода."
  },
  {
    "question": "Что означает принцип открытости/закрытости (Open/Closed Principle)?",
    "answer": "Классы должны быть открыты для расширения, но закрыты для изменения. Это означает, что поведение класса можно расширять, не изменяя его исходный код.  \nПример: Вместо того, чтобы изменять существующие методы класса, можно создать подклассы, которые расширяют функциональность."
  },
  {
    "question": "Что означает принцип подстановки Лисков (Liskov Substitution Principle)?",
    "answer": "Объекты подклассов должны быть взаимозаменяемы с объектами базового класса без нарушения работы программы. Если подкласс изменяет поведение базового класса так, что это вызывает проблемы, то это нарушает принцип Лисков.  \nПример: Если у нас есть класс \"Животное\", а от него наследуется класс \"Собака\", то объект \"Собака\" должен вести себя так же, как и объект \"Животное\", когда используется в коде."
  },
  {
    "question": "Что означает принцип разделения интерфейса (Interface Segregation Principle)?",
    "answer": "Классы, реализующие интерфейс, не должны зависеть от интерфейсов, которые они не используют. Это означает, что большие интерфейсы нужно разделять на более мелкие, чтобы классы могли работать только с теми методами, которые им действительно нужны.  \nПример: Если интерфейс содержит методы для работы с документами и изображениями, а класс работает только с документами, то следует разделить этот интерфейс на два, чтобы класс не зависел от методов, с которыми он не работает."
  },
  {
    "question": "Что означает принцип инверсии зависимостей (Dependency Inversion Principle)?",
    "answer": "Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций. Также, абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.  \nПример: Вместо того, чтобы класс зависел от конкретного типа объекта (например, от класса \"DatabaseConnection\"), он должен зависеть от абстракции (например, интерфейса \"DatabaseConnectionInterface\"), что позволяет легче менять реализацию без изменения основного класса."
  },
  {
    "question": "Что такое BLoC?",
    "answer": "BLoC — это архитектурный паттерн, который отделяет бизнес-логику от пользовательского интерфейса. Он помогает создавать приложения с четкой структурой, что особенно полезно для тестируемости и масштабируемости.\nОсновная идея: пользовательский интерфейс (UI) взаимодействует с бизнес-логикой через потоки данных (Streams), обеспечивая реактивный подход."
  },
  {
    "question": "Какие основные компоненты есть в BLoC?",
    "answer": "Основные компоненты BLoC:\n● Events (События):\n  ● Пользовательские действия или внешние триггеры (например, нажатие кнопки).\n  ● Передаются в BLoC для обработки.\n● State (Состояние):\n  ● BLoC возвращает новое состояние на основе обработанного события.\n  ● Это состояние передается в UI, который обновляется автоматически.\n● Streams:\n  ● Используются для передачи данных между BLoC и UI.\n  ● Входящий поток: события.\n  ● Исходящий поток: состояние."
  },
  {
    "question": "Как работает BLoC?",
    "answer": "1. Пользователь взаимодействует с UI (например, нажимает кнопку).\n2. UI отправляет событие в BLoC.\n3. BLoC обрабатывает событие, выполняя бизнес-логику (например, обращение к API или работе с базой данных).\n4. На основе результата BLoC эмитирует новое состояние.\n5. UI подписывается на поток состояний и обновляется автоматически."
  },
  {
    "question": "Какие преимущества у BLoC?",
    "answer": "Преимущества BLoC:\n1. Разделение ответственности:\n   ● UI и бизнес-логика отделены, что улучшает читаемость кода.\n2. Масштабируемость:\n   ● Легко добавлять новые функции, не затрагивая другие модули.\n3. Тестируемость:\n   ● Бизнес-логику можно тестировать отдельно от UI.\n4. Универсальность:\n   ● Работает на всех платформах Flutter (мобильных, веб, десктопных)."
  },
  {
    "question": "Когда стоит использовать BLoC?",
    "answer": "Когда использовать BLoC:\n● Если проект:\n  ● Сложный и требует четкого разделения слоёв.\n  ● Нужно управлять состоянием, зависящим от событий (например, фильтрация, поиск, авторизация).\n  ● Требует высокой тестируемости.\n● В небольших приложениях можно обойтись более простыми подходами, такими как Provider или Riverpod."
  },
  {
    "question": "Что такое ChangeNotifier?",
    "answer": "ChangeNotifier — это класс, который используется для управления состоянием в приложении. Он уведомляет подписчиков (например, виджеты), когда происходит изменение данных. Это удобно для реализации паттерна наблюдатель. \nЧтобы подписаться на изменения, нужно использовать метод addListener. Для уведомления нужно вызвать notifyListeners."
  },
  {
    "question": "Что такое ValueNotifier?",
    "answer": "ValueNotifier — это упрощённая версия ChangeNotifier, которая работает с одним значением. Он уведомляет слушателей, когда это значение изменяется. Это полезно для простых сценариев, где нужно отслеживать одно состояние, например, текущий индекс или выбранный элемент."
  },
  {
    "question": "Как ChangeNotifier связан с другими паттернами?",
    "answer": "ChangeNotifier часто используется с Provider, чтобы интегрировать управление состоянием в дерево виджетов."
  },
  {
    "question": "Как ValueNotifier связан с другими паттернами?",
    "answer": "ValueNotifier не требует Provider, но может использоваться с ValueListenableBuilder, который упрощает работу с UI."
  },
  {
    "question": "Чем отличаются ChangeNotifier и ValueNotifier?",
    "answer": "ValueNotifier работает с одним значением и имеет встроенное поле value, которое легко изменяется и отслеживается. \nChangeNotifier более гибкий и используется для управления сложными состояниями. Можно создавать произвольные свойства и методы, а затем уведомлять слушателей о любых изменениях."
  },
  {
    "question": "Какие подходы для управления навигацией предлагает Flutter?",
    "answer": "Flutter предлагает два подхода для управления навигацией в приложении:\n● Navigation 1.0 (Imperative API) – традиционная императивная навигация.\n● Navigation 2.0 (Declarative API) – более современный и гибкий подход."
  },
  {
    "question": "Как работает Navigation 1.0 (Императивный подход)?",
    "answer": "● Как работает:\n  - Используется класс Navigator, который управляет стеком маршрутов (Route).\n  - Навигация осуществляется с помощью методов:\n    ● Navigator.push() — добавление нового маршрута в стек.\n    ● Navigator.pop() — удаление текущего маршрута.\n  - Каждый маршрут добавляется или удаляется из стека явно, по команде.\n● Простота и ограничение:\n  - Этот подход подходит для линейных сценариев навигации или небольших приложений.\n  - Проблемы возникают при работе со сложными сценариями:\n    ● Глубокая вложенность маршрутов.\n    ● Поддержка глубоких ссылок (deep linking).\n    ● Сложность синхронизации состояния с URL (особенно в веб-приложениях)."
  },
  {
    "question": "Как работает Navigation 2.0 (Декларативный подход)?",
    "answer": "● Как работает:\n  - Навигация определяется состоянием приложения.\n  - Включает следующие ключевые компоненты:\n    ● Router и RouteInformationParser — обрабатывают входящие данные маршрута (например, URL).\n    ● RouterDelegate — управляет текущим состоянием и интерфейсом навигации.\n    ● Navigator внутри Router используется для работы со стеком экранов.\n● Преимущества:\n  - Полный контроль над состоянием приложения.\n  - Легкость работы с глубокими ссылками и платформенными маршрутами (например, веб-URL).\n  - Удобство для реализации сложных сценариев навигации.\n● Недостатки:\n  - Реализация сложнее по сравнению с Navigation 1.0."
  },
  {
    "question": "Какие основные отличия между декларативной и императивной навигацией?",
    "answer": "● Императивная навигация (Navigation 1.0):\n  - Разработчик явно управляет переходами с помощью вызовов функций (Navigator.push()).\n  - Это удобно для простых сценариев, но плохо масштабируется в сложных приложениях.\n● Декларативная навигация (Navigation 2.0):\n  - Навигация определяется состоянием приложения, а не прямыми вызовами.\n  - Вы описываете, какие маршруты доступны, а система автоматически синхронизирует интерфейс с состоянием."
  },
  {
    "question": "Как реализована декларативная навигация в go_router?",
    "answer": "● Особенности:\n  - Навигация описывается в виде конфигурации:\n    ● Указывается начальный маршрут, дочерние маршруты и параметры.\n  - Используются методы, такие как context.go() и context.push(), чтобы изменить состояние навигации.\n● Проявление декларативности:\n  - Маршруты определены как часть состояния приложения.\n  - Изменение маршрута изменяет состояние, а не управляет навигацией напрямую."
  },
  {
    "question": "Как реализована декларативная навигация в auto_route?",
    "answer": "● Особенности:\n  - Используются аннотации для описания маршрутов, и маршруты генерируются автоматически.\n  - Переходы между страницами осуществляются с помощью объектов, например, PetDetailsRoute.\n● Проявление декларативности:\n  - Навигация строится через аннотации и состояние приложения.\n  - Генерация кода упрощает управление маршрутами, исключая необходимость ручного управления состоянием."
  },
  {
    "question": "Что представляет собой StatelessWidget и в каких случаях его используют?",
    "answer": "• Описание: StatelessWidget представляет неизменяемые части интерфейса. Используется, когда состояние не изменяется после инициализации.\n\n• Как работает: При вызове метода build() создаётся дерево виджетов, которое Flutter рендерит на экране. Если нужно изменить отображение, создаётся новый экземпляр этого виджета.\n\n• Примеры использования: Отображение статических элементов, например, текст, изображения или иконки."
  },
  {
    "question": "Чем отличается StatefulWidget от StatelessWidget и как он функционирует?",
    "answer": "• Описание: StatefulWidget используется для элементов, которые могут изменять своё состояние во время работы приложения. Этот виджет разделён на две части: сам виджет и его состояние.\n\n• Как работает: StatefulWidget описывает неизменяемую часть (например, тип контента или маршруты), а State хранит данные, которые можно изменять. При изменении состояния вызывается setState(), и build() перерисовывает интерфейс.\n\n• Примеры использования: Таймеры, кнопки, которые переключают свои состояния, динамически обновляемые списки."
  },
  {
    "question": "Что такое InheritedWidget и как он используется в приложениях Flutter?",
    "answer": "• Описание: InheritedWidget используется для передачи данных в дереве виджетов без необходимости явно передавать их через конструкторы. Обеспечивает доступ к данным всем потомкам в дереве.\n\n• Как работает: Создаётся в корне дерева виджетов. Если данные изменяются, зависимые виджеты перерисовываются.\n\n• Примеры использования: Реализация глобального состояния, темизации, управления локализацией. В современных приложениях часто заменяется на Provider или Riverpod."
  },
  {
    "question": "Какие стандартные компоненты Flutter используют InheritedWidget и как они функционируют?",
    "answer": "• Theme: Управляет глобальными параметрами оформления приложения. Виджеты запрашивают тему через Theme.of(context), что вызывает context.dependOnInheritedWidgetOfExactType. Изменение темы обновляет все виджеты, зависящие от темы.\n\n• MediaQuery: Предоставляет информацию об устройстве, например размеры экрана, плотность пикселей. Использует InheritedWidget для распространения этих данных по дереву. При изменении устройства перерисовываются зависимые виджеты.\n\n• Navigator: Управляет стеком маршрутов и переходами между экранами. Контекст навигатора передаётся через Navigator.of(context).\n\n• Directionality: Определяет направление текста (LTR/RTL). Изменение локализации обновляет зависимые виджеты.\n\n• Localizations: Управляет переводами и локализацией. Через Localizations.of(context) виджеты получают доступ к строкам интерфейса.\n\n• DefaultTextStyle: Определяет стиль текста, используемый дочерними текстовыми виджетами. При изменении стиля обновляются все текстовые виджеты.\n\n• FocusScope: Управляет состоянием фокуса. Распространяет информацию о текущем элементе фокуса."
  },
  {
    "question": "Почему использование InheritedWidget важно для производительности и архитектуры приложения?",
    "answer": "• Обновляются только виджеты, которые зависят от состояния. Это снижает нагрузку на перерисовку.\n\n• Упрощается доступ к данным: разработчику не нужно явно передавать их через конструкторы, что делает код чище.\n\n• Состояние становится инкапсулированным и доступным в любой части дерева виджетов. Это упрощает управление состоянием и улучшает архитектуру приложения."
  },
  {
    "question": "Что такое верстка в контексте Flutter и почему она важна?",
    "answer": "• Верстка в Flutter — это процесс построения пользовательского интерфейса (UI) с использованием набора виджетов, которые комбинируются для создания сложных экранов.\n\n• Все элементы интерфейса в Flutter, включая текст, изображения, кнопки и контейнеры, представлены виджетами."
  },
  {
    "question": "Какие ключевые навыки необходимы для правильной верстки в Flutter?",
    "answer": "• Понимание структуры дерева виджетов:\n  - Flutter работает через концепцию \"дерева виджетов\".\n  - Виджеты могут быть:\n    - Контейнерными (например, Container, Column, Row), которые управляют расположением других виджетов.\n    - Функциональными (например, Text, Image, Button), которые отображают конкретный контент. Грамотная верстка включает оптимизацию структуры дерева для повышения производительности.\n\n• Правильное использование виджетов:\n  - Умение выбирать виджеты в зависимости от задач:\n    - Использование ListView для длинных списков.\n    - Stack для наложения виджетов.\n    - SizedBox или Spacer для отступов.\n\n• Адаптивный дизайн:\n  - Подстройка интерфейса под разные размеры экранов:\n    - Использование MediaQuery или LayoutBuilder.\n    - Применение виджетов типа Expanded или Flexible в комбинации с Row и Column.\n\n• Работа с состоянием:\n  - Умение добавлять интерактивность через StatefulWidget или управление состоянием (например, с помощью Provider, Bloc или Riverpod)."
  },
  {
    "question": "Как правильно выбрать между Row и Column в процессе верстки?",
    "answer": "• Row используется для размещения виджетов по горизонтали, а Column — по вертикали.\n\n• Важно учитывать ограничения по размеру родительского контейнера, чтобы избежать ошибок переполнения и обеспечить корректное отображение."
  },
  {
    "question": "Что такое 'constraints' в Flutter и какую роль они играют в верстке?",
    "answer": "• Constraints — это ограничения размера, которые Flutter применяет к виджету.\n\n• Эти ограничения передаются от родительского виджета к дочерним и определяют их минимальные и максимальные размеры.\n\n• Constraints обеспечивают согласованность интерфейса и помогают избежать ошибок отображения."
  },
  {
    "question": "Как добиться адаптивности интерфейса в приложении на Flutter?",
    "answer": "• Используйте MediaQuery для получения информации о размере экрана, плотности пикселей и других параметров устройства.\n\n• Применяйте гибкие виджеты, такие как Flexible и FractionallySizedBox, которые адаптируют размер дочерних виджетов в зависимости от доступного пространства.\n\n• Используйте LayoutBuilder для создания интерфейса, реагирующего на изменения размеров контейнеров."
  },
  {
    "question": "Что такое Null-Safety в Flutter/Dart и для чего она используется?",
    "answer": "• Null-Safety в Flutter/Dart – это механизм языка, предотвращающий ошибки, связанные с доступом к объектам, которые имеют значение null. Он помогает писать более безопасный и стабильный код.\n\n• Null-Safety используется для:\n  - Предотвращения ошибок времени выполнения:\n    - Ошибки, связанные с попыткой доступа к методам или свойствам объекта, равного null, являются одной из самых распространённых причин падения программ. Null-Safety устраняет эту проблему на этапе компиляции.\n  - Улучшения читаемости и поддержки кода:\n    - Код становится более предсказуемым. Разработчик всегда знает, где и как возможны значения null.\n  - Повышения производительности:\n    - Отсутствие необходимости проверки на null в рантайме может ускорить выполнение программы."
  },
  {
    "question": "Как устроена Null-Safety в Dart?",
    "answer": "• Типы данных:\n  - В Dart все типы по умолчанию not-nullable (не допускают значения null).\n  - Чтобы переменная могла быть null, используется суффикс ? (nullable типы).\n\n• Оператор безопасного доступа (?.):\n  - Позволяет обращаться к свойствам объекта, который может быть null, без риска ошибки.\n\n• Оператор принудительного раскрытия bang-operator (!):\n  - Используется, если разработчик уверен, что значение не будет null.\n\n• Late-инициализация (late):\n  - Применяется для переменных, которые инициализируются позже, но точно получат значение до использования."
  },
  {
    "question": "Какие практики помогают правильно использовать Null-Safety?",
    "answer": "• Инициализируйте переменные сразу, где это возможно.\n\n• Используйте nullable типы только там, где это необходимо: если значение переменной может быть null, явно обозначьте это с помощью ?.\n\n• Используйте операторы ?. или ?? для указания значений по умолчанию.\n\n• Избегайте чрезмерного использования оператора !: этот оператор опасен, так как может привести к падению программы, если разработчик ошибся.\n\n• Проверяйте значения перед доступом:\n  - if (name != null) {\n    print(name.length);\n  }"
  },
  {
    "question": "Какие преимущества Null-Safety предоставляет в процессе разработки?",
    "answer": "• Предотвращение ошибок, связанных с null, на этапе компиляции. Это значительно снижает вероятность ошибок времени выполнения.\n\n• Улучшение читаемости кода, так как разработчик явно видит, какие переменные допускают null, а какие нет.\n\n• Повышение производительности, поскольку не нужно выполнять дополнительные проверки на null в рантайме."
  },
  {
      "question": "Что такое Future в Dart и когда его следует использовать?",
      "answer": "• Future представляет собой одноразовую асинхронную операцию, которая завершится в будущем с результатом или ошибкой.\n\n• Когда использовать Future:\n  - Для выполнения единичных операций, таких как:\n    - Запрос данных с сервера (HTTP-запрос).\n    - Чтение файла.\n    - Таймер или задержка (например, Future.delayed).\n  - Когда результат нужен один раз."
    },
    {
      "question": "Что такое Stream в Dart и для чего он предназначен?",
      "answer": "• Stream представляет собой поток данных, который может выдавать одно или несколько значений с течением времени.\n\n• Когда использовать Stream:\n  - Для работы с последовательностью событий или данных, таких как:\n    - Реакция на пользовательские действия.\n    - Загрузка данных в реальном времени (например, WebSocket, сокеты).\n    - Потоковые API (стриминг аудио/видео).\n    - Обновление интерфейса на основе поступающих данных."
    },
    {
      "question": "Что такое Isolate в Dart и зачем он нужен?",
      "answer": "• Isolate — это отдельный поток выполнения в Dart, который не делит память с главным потоком (в отличие от потоков в других языках).\n\n• Isolate используется для выполнения тяжелых вычислений или задач, которые могут заблокировать главный поток (и, соответственно, интерфейс в Flutter).\n\n• Когда использовать Isolate:\n  - Для задач, требующих высокой вычислительной мощности:\n    - Парсинг большого JSON.\n    - Обработка изображений или видео.\n    - Криптографические вычисления."
    },
    {
      "question": "Как правильно использовать Isolate для выполнения вычислительных задач?",
      "answer": "• Для общения между Isolate и главным потоком используются порты (ReceivePort и SendPort).\n\n• Isolate создаётся для выполнения тяжёлых вычислений, чтобы главный поток оставался доступным для пользовательского интерфейса.\n\n• Пример использования: если нужно обработать большие файлы, можно передать задачу в Isolate, а результат вернуть через SendPort."
    },
    {
      "question": "Как правильно выбрать между Future, Stream и Isolate?",
      "answer": "• Используйте Future, если нужно выполнить единичную асинхронную задачу.\n  - Пример: HTTP-запрос на сервер для получения данных.\n\n• Используйте Stream, если данные поступают в течение времени.\n  - Пример: Наблюдение за изменениями состояния, сокеты, пользовательский ввод.\n\n• Используйте Isolate для тяжелых вычислений, которые нельзя выполнять на основном потоке.\n  - Пример: Парсинг или обработка больших файлов."
    },
    {
      "question": "Какие примеры задач подходят для Future, Stream и Isolate?",
      "answer": "• Future:\n  - Запрос к серверу через HTTP.\n  - Чтение небольших файлов.\n  - Таймеры и задержки (Future.delayed).\n\n• Stream:\n  - Обработка последовательных событий, таких как ввод пользователя.\n  - Поток данных через WebSocket.\n  - Обновление интерфейса в реальном времени.\n\n• Isolate:\n  - Парсинг больших JSON-файлов.\n  - Обработка изображений или видео.\n  - Сложные математические или криптографические вычисления."
    },
  {
      "question": "Что такое асинхронность в Dart и как она организована?",
      "answer": "• Асинхронность в Dart построена вокруг фьючеров (Future), стримов (Stream) и ключевых слов async/await. Эти механизмы позволяют писать код, который выполняется асинхронно, не блокируя основной поток исполнения.\n\n• Основные концепции асинхронности:\n  - Event Loop (Цикл событий): Dart использует однопоточный цикл событий для управления выполнением асинхронного кода. Все задачи делятся на:\n    - Микрозадачи (Microtasks): Задачи с высоким приоритетом (например, обработка завершения Future).\n    - Задачи из очереди событий (Event Queue): Более крупные задачи (например, события пользовательского интерфейса или таймеры).\n    Event loop обрабатывает сначала все микрозадачи, а затем переключается на задачи из очереди событий."
    },
    {
      "question": "Что такое Future и как он используется в асинхронности?",
      "answer": "• Future представляет собой операцию, которая завершится в будущем с результатом или ошибкой.\n\n• Future используется для выполнения одиночных асинхронных операций, таких как запрос данных с сервера, задержки выполнения или чтение файлов.\n\n• Пример: Future.delayed(Duration(seconds: 2), () => print(\"Hello\")) выполняет задержку перед выводом текста."
    },
    {
      "question": "Как работает Stream и какие его типы существуют?",
      "answer": "• Stream — это последовательность асинхронных данных (например, поток событий или запросов).\n\n• Stream позволяет работать с множественными событиями, поступающими во времени. Его использование актуально для работы с пользовательскими действиями, WebSocket или потоками данных.\n\n• Есть два типа стримов:\n  - Одноразовые (Single-Subscription): обрабатываются одним подписчиком и подходят для линейной последовательности данных.\n  - Широковещательные (Broadcast): могут обрабатываться несколькими подписчиками одновременно."
    },
    {
      "question": "Как работают ключевые слова async и await в Dart?",
      "answer": "• Ключевое слово async обозначает, что функция выполняется асинхронно и возвращает Future. Это упрощает написание асинхронного кода, делая его похожим на синхронный.\n\n• Ключевое слово await используется для приостановки выполнения функции до завершения Future, позволяя обработать результат после завершения задачи.\n\n• Пример:\n  ```dart\n  Future<void> fetchData() async {\n    var result = await fetchFromServer();\n    print(result);\n  }\n  ```"
    },
    {
      "question": "Как асинхронность интегрирована в Flutter?",
      "answer": "• Асинхронность активно используется в Flutter для работы с API, загрузки данных, выполнения анимаций и других длительных операций.\n\n• Flutter обеспечивает отзывчивость интерфейса за счёт того, что асинхронные операции не блокируют основной поток выполнения (UI thread).\n\n• Пример: можно использовать FutureBuilder для отображения данных, которые загружаются асинхронно, обновляя интерфейс автоматически при завершении Future."
    },
    {
      "question": "Что такое Event Loop и как он влияет на выполнение задач?",
      "answer": "• Event Loop — это механизм, управляющий выполнением задач в Dart. Он обрабатывает задачи в двух очередях:\n  - Микрозадачи (Microtasks): задачи с высоким приоритетом, такие как завершение Future.\n  - Очередь событий (Event Queue): задачи, связанные с пользовательским интерфейсом или таймерами.\n\n• Event Loop сначала обрабатывает микрозадачи, а затем переключается на задачи из очереди событий. Это позволяет управлять порядком выполнения задач и сохранять отзывчивость приложения."
    },
    {
      "question": "Как обработать асинхронные ошибки в Dart?",
      "answer": "• Асинхронные ошибки обрабатываются с помощью try-catch или метода onError.\n\n• Если Future завершился с ошибкой, её можно перехватить и обработать:\n  ```dart\n  Future<void> fetchData() async {\n    try {\n      var data = await fetchFromServer();\n      print(data);\n    } catch (e) {\n      print(\"Ошибка: $e\");\n    }\n  }\n  ```"
    },
    {
      "question": "Когда использовать Isolate для асинхронных операций?",
      "answer": "• Isolate используется для выполнения тяжелых задач, которые могут заблокировать основной поток выполнения. Это отдельные потоки, которые не делят память с основным потоком.\n\n• Примеры задач для Isolate:\n  - Парсинг большого JSON.\n  - Обработка изображений или видео.\n  - Криптографические вычисления.\n\n• Общение между Isolate и основным потоком осуществляется через ReceivePort и SendPort."
    },
    {
      "question": "Что такое Git и для чего он используется?",
      "answer": "• Git — это распределённая система контроля версий, которая позволяет отслеживать изменения в коде, управлять версиями проекта и работать в команде.\n\n• Используется для:\n  - Хранения истории изменений в проекте.\n  - Совместной работы над кодом.\n  - Восстановления кода в случае ошибок."
    },
    {
      "question": "Как подключить Git к проекту?",
      "answer": "• Инициализация репозитория:\n  - git init — создаёт локальный репозиторий в текущей папке.\n\n• Клонирование репозитория:\n  - git clone <url> — копирует удалённый репозиторий на ваш компьютер.\n\n• Добавление удалённого репозитория:\n  - git remote add origin <url> — связывает локальный репозиторий с удалённым."
    },
    {
      "question": "Какие основные команды используются в Git?",
      "answer": "• Работа с изменениями:\n  - git status — проверяет текущее состояние репозитория.\n  - git add <файл> — добавляет файл в индекс для фиксации.\n  - git commit -m \"Комментарий\" — создаёт коммит с описанием изменений.\n\n• Работа с ветками:\n  - git branch — показывает список веток.\n  - git branch <имя> — создаёт новую ветку.\n  - git checkout <ветка> — переключается на указанную ветку.\n  - git checkout -b <имя> — создаёт и переключается на новую ветку.\n\n• Слияние и обновление:\n  - git merge <ветка> — сливает изменения из указанной ветки.\n  - git pull — скачивает изменения из удалённого репозитория и сливает их.\n  - git push — отправляет изменения в удалённый репозиторий.\n\n• Работа с удалённым репозиторием:\n  - git fetch — скачивает изменения, но не сливает их.\n  - git push origin <ветка> — отправляет локальную ветку на сервер.\n\n• Просмотр истории и изменений:\n  - git log — показывает историю коммитов.\n  - git diff — отображает различия между текущими и последними сохранёнными изменениями."
    },
    {
      "question": "Как организовать совместную работу с другими разработчиками в Git?",
      "answer": "• Использование веток:\n  - Каждый разработчик работает в своей ветке, чтобы избежать конфликтов.\n  - Основные ветки: main или master (основная), develop (разработка).\n\n• Решение конфликтов:\n  - Если два человека изменили один и тот же файл, при слиянии (merge) может возникнуть конфликт.\n  - Используйте git status и вручную исправляйте конфликты, затем git add и git commit.\n\n• Код-ревью:\n  - Создайте pull request (PR) или merge request (MR) через платформы, такие как GitHub или GitLab.\n  - PR — это запрос на проверку и слияние изменений в основную ветку."
    },
    {
      "question": "Что такое Git Flow и как его использовать?",
      "answer": "• Git Flow — это стратегия работы с ветками, которая используется в командах.\n\n• Основные ветки:\n  - main (или master) — содержит только стабильный код.\n  - develop — для текущей разработки.\n\n• Дополнительные ветки:\n  - feature/* — для разработки новых функций.\n  - release/* — для подготовки к выпуску.\n  - hotfix/* — для исправления критических багов.\n\n• Пример Git Flow:\n  - Создаёте ветку feature/new-feature от develop.\n  - Вносите изменения, делаете коммиты.\n  - После завершения работы сливаетесь с develop."
    },
    {
      "question": "Как выглядит пример простого сценария работы с Git?",
      "answer": "• Клонируете репозиторий:\n  git clone https://github.com/username/project.git\n\n• Создаёте новую ветку:\n  git checkout -b feature/my-feature\n\n• Вносите изменения и фиксируете их:\n  git add .\n  git commit -m \"Added my new feature\"\n\n• Отправляете изменения на сервер:\n  git push origin feature/my-feature\n\n• Создаёте pull request для слияния изменений в основную ветку."
    }
]

